# 《The Byzantine Generals Problem》译文

## 摘要

一个可靠的计算机系统必须处理有故障的组件，这些组件可能引入与系统其它部分相冲突的信息。这样的场景可以用一组指挥军队围困敌国城市的拜占庭将军来描述。将军之间只能通过信使传递信息，他们必须在相同的作战方案上达成一致。但是，他们之中可能存在叛徒，这些叛变的将军会竭力的扰乱其它人。拜占庭将军问题，就是指找到一种算法可以保证那些忠诚的将军可以达成一致。结果表明，如果使用口头信息，当且仅当超过三分之二的将军是忠诚的时候该问题才可解，也就是说一个将军可以扰乱两个将军。如果使用不可伪造的书面信息，对于任何数目的将军和叛徒，该问题都是可解的。此外，本文还讨论了如何将该问题的解应用于可靠的计算机系统实现中。

## 1、导引（INTURUCTION）

一个可靠的计算机系统必须能够处理一个或多个的组件的失败。一个失败的组件可能会表现出一种经常被忽略的行为：向系统的其他部分发送相矛盾的信息。可以将处理这种失败的情况的问题抽象出来，就是这里的拜占庭将军问题。我们在论文的绝大部分内容都是讨论这个抽象后的问题，只是在末尾会讨论如何将该问题的解应用在可靠计算机系统的实现中。

假设有几股拜占庭军队现在正在一个敌城外扎营，每股军队由一个将军指挥。将军之间只能通过信使通信。观察完敌情后，他们必须达成一个相同的行动计划。然而，有些将军可能是叛徒，他们会尽力阻止那些忠诚的将军达成一致。将军们必须有一个算法来保证如下条件：

>A.所有忠诚的将军必须达成相同的行动计划。

忠诚的将军将会做该算法要求他们做的事情，但是叛变的将军可以做任何他们想做的事情。无论叛变的将军会做什么，算法必须要保证条件A。

诚实的将军不能仅仅达成一致，他们还应该达成一个合理的行动计划。也就是说，实际上我们想保证：

 >B.当只有少数人是叛徒的时候，他们不能导致那些诚实的将军们采纳一个糟糕的计划。

条件B很难去形式化，因为它需要精确的定义何谓糟糕的计划，当然我们也并不尝试去给出这样的一个定义。我们来考虑将军们如何做出决定，每个将军都会观察敌情，并将他的观察结果告诉其他将军。假设v(i)代表第i个将军发送的信息。每个将军使用某种方法来根据这些信息v(1),v(2)……v(n)来拟定作战计划(n代表将军的总数)。通过让所有的将军使用同一种方法就可以满足条件A，通过使用一种健壮的方法条件B也可以满足。比如，现在需要决定是进攻还是撤退，v(i)代表第i个将军关于进攻还是撤退的意见，最终的决定可以通过在他们之间进行一个多数决的投票来决定。在这种情况下，只有当持两种意见的忠诚将军数目几乎相同时，少数的叛变将军才能影响最终的结果。但是这种情况下，无论是进攻还是撤退都算不上是糟糕的方案，这就说明满足条件B。

虽然这种策略可能不是满足条件A和B的唯一一种方式，但是目前我们仅想到这一个。该方法假设存在一种方法，将军们可以相互传递各自的v(i)值。很明显的一种方法是，将军i，让他的信使将v(i)送给所有的将军。但是，这样行不通，因为如果要满足条件A，需要每个忠诚的将军收到相同的v(1),v(2)……v(n)，但是一个叛变的将军可能会给不同的将军发送不同的值。对于条件A来说，如果要满足，下面的条件必须成立：

> 1.每个忠诚的将军必须收到相同的v(1),v(2)……v(n)

条件1暗示一个将军并没有必要使用一个直接从第i个将军那收到的v(i)值，因为一个叛变的第i将军可能给不同的将军发送不同的v(i)值。但是这样意味着，满足条件1的同时，很可能一不小心就使用了一个与第i将军发送的v(i)不同的值，即使第i个将军是诚实的{!因为我们可能采用了从其他将军处得来的关于v(i)的值，但是这个将军可能是叛变者，它可能自己已经改变了v(i)的值，这样即使第i将军是诚实的，但是经过叛变者之后它的值也已不再受控了}。但是为了满足条件B，我们绝不允许这种情况发生。比如我们，我们不能允许少数的叛变者就使得忠诚的将军们在一个个”retreat”, ”retreat”…… ”retreat”,中做决定，而每个忠诚的将军发送的明明是”attack”。因此，我们还要为每个i增加如下的需求：

> 2.如果第i个将军是忠诚的，那么其他的忠诚的将军必须使用他发送的值作为v(i)的值。

![算法要求1](./算法要求1.png)

我们可以改写条件1，使得它是针对任意i的条件(无论第i个将军是否是忠诚的)：

>1’. 任意两个忠诚的将军使用相同的v(i)值

![算法要求2](./算法要求2.png)

条件1’.和2现在都是针对第i个将军的值v(i)的了。因此，我们可以只考虑一个将军如何发送他的值给其他人。现在我们用一个发令将军向它的下属发送命令的形式来重新描述这个问题，就得到如下问题：

拜占庭将军问题。一个发令将军向他的n-1个下属将军发送命令，使得：

>IC1.所有忠诚的下属都遵守相同的命令  
IC2.如果发令将军是忠诚的，那么每个忠诚的下属必须遵守他发出的命令

![问题描述2](./问题描述2.png)

条件IC1和IC2被称为交互一致性(interactive consistency)条件。可以看到，当发令将军是忠诚的时候，IC1可以由IC2导出。然而，发令将军不一定是忠诚的。

为了解决最初的问题，第i个将军只需要利用拜占庭将军问题的解法发送命令”使用v(i)作为我的值”，就可以将他的值v(i)发送给其他的将军。此时其他的将军就扮演拜占庭将军问题中的下属的角色。

## 2、不可能性（IMPOSSIBILITY RESULTS ）

拜占庭将军问题看似很简单。它的难解之处是通过一个令人惊讶的事实而体现出来的：如果将军们只能发送口头消息，除非有超过三分之二的将军是忠诚的，否则该问题无解。尤其是，如果只有三个将军，其中一个是叛变者，那么此时无解。口头消息是指信息的内容完全在发送者控制之下，这样一个叛变了的发送者可能会传送任何可能的消息。正常情况下计算机之间传输的消息就属于这种类型。在第4节，我们会考虑签名的，书面消息，对于这种类型该结论不成立。

我们现在来说明使用口头消息，当三个将军中有一个叛变时是无解的。为了简单起见，我们只考虑是”进攻”还是”撤退”这一简单的决定的情况。首先看图1里的情形，发令者是忠诚的并且发送了一个”进攻”命令。但是下属2是个叛变者，他对下属1说，他收到了一个”撤退”命令。如果要保证IC2满足，将军1必须遵守命令去进攻。

现在考虑图2所展示的另一种情形，发令者是一个叛变的将军，发送了一个“进攻”命令给下属1，但是给2发送的是“撤退”命令。下属1，不知道谁是叛变者，同时他也无法判断发令者发送给下属2的真实的命令到底是什么。因此，这两幅图中的情形，对于1来说是完全相同的。他不知道谁是叛变者，两种情况下他都是只知道发令者告诉他要进攻，但是2说发令者说要撤退。所以他无法区分出这两种情形，但是如果是情形1，他必须进攻，如果是情形2他如果也进攻，那就是说无论如何他都听发令者的命令，如果选定了这1算法，因为1,2本质上是等价的角色，那么2也需要采纳该算法，这样2就会选择撤退，这就违发了IC1。如果他选择撤退，那么意味着他要区分这两种情况，但是实际它是无法区分的，因此无解。如果叛变者总是在说谎的话，对于1来说就无法区分这两种情况，因此他就必须选择遵守进攻命令，因此无论何时，下属1从发令者那收到进攻命令，他都必须遵守它。

然而，类似的结论也指出，进攻与撤退不过是两个称谓，将2者互换一下就可以得出结论，如果下属2从发令者那收到了撤退命令，他都必须要遵守，即使1告诉他发令者的命令是进攻。因此对于图2的情形来说，2必须遵守撤退命令，而1必须遵守进攻命令，因此违法了条件IC1。因此 *三个将军中有一个是叛变者时，该问题无解。*

![two and one traitor](./fig1and2.png)

这个结论可能看起来很令人信服，但是我们仍然强烈的建议读者对这种非严格的推理保持怀疑态度。尽管该结论实际上也是正确的，但是我们也碰到过对一些错误结论的类似这样的似是而非的证明。在计算机科学和数学领域中，非严格的证明在对这种类型的算法研究中最有可能导致错误了。对于该问题的严格证明可以参考[《Reaching agreement in the presence of faults》](https://www.microsoft.com/en-us/research/publication/reaching-agreement-presence-faults/)

利用这个结论，我们可以说明当有m个叛徒，而将军数小于3m+1时，该问题无解。证明采用反证法：我们假设当将军数小于等于3m时存在一个解，然后用它来构造一个 *three-general solution* 的拜占庭将军问题解（即共有3个将军，其中1个是叛徒），我们知道其实这样的解是不存在的。为了避免这两个算法的混淆，我们将假设解中的将军们叫做阿尔巴尼亚将军，构造解中的将军叫做拜占庭将军。因此，下面我们从一个允许有m个叛徒，但阿尔巴尼亚将军小于等于3m的算法开始，我们来构造一个 *three-general solution* 。

这个 *three-general solution* 是通过让拜占庭将军解中的每个拜占庭将军来模拟1/3的阿尔巴尼亚将军们（注：总数≤3m个）来得到的，这样每个拜占庭将军最多模拟m个阿尔巴尼亚将军。拜占庭的发令将军来模拟阿尔巴尼亚发令将军以及最多m-1个阿尔巴尼亚下属将军。两个拜占庭下属将军中的任意一个模拟最多m个阿尔巴尼亚下属将军。由于只有一个拜占庭将军是叛徒，而且他最多可以模拟m个阿尔巴尼亚将军，而最多只有m个阿尔巴尼亚将军是叛徒。因此，假设解可以确保IC1和IC2对于阿尔巴尼亚将军是成立的。根据IC1，被一个忠诚的拜占庭下属将军模拟的阿尔巴尼亚下属将军们都遵守相同的命令，这个命令也是他应该遵守的那个命令。很容易看出阿尔巴尼亚将军解的条件IC1和IC2也隐含着拜占庭将军的相应条件，这样我们就构造出了那个不可能的解。（ ~~**此处并不理解**~~ ）{一种解释：模拟属于外部行为，也就是说将军之间不知道谁是叛徒，但是我们在模拟的时候，可以知道这些情况，而让叛变的那个拜占庭将军模拟叛变的那些阿尔巴尼亚将军，然后把拜占庭将军放到阿尔巴尼亚将军的执行环境中，他们一人扮演多个将军，执行阿尔巴尼亚将军解的算法，阿尔巴尼亚将军之间可以保证IC1和IC2这两个条件，而拜占庭将军只需要遵守他所扮演的将军们所遵守的那些命令，就达到了他自己的IC1和IC2条件}

可能有人认为解决拜占庭将军问题的难点在于它要求达到精确的一致。下面我们通过证明近似一致实际与精确一致一样困难,来说明情况并不是这样。我们现在假设不是要达到一个精确的战斗计划，将军们只需要达成近似的进攻时间。详细来说，我们假设发令者需要确定进攻时间，同时需要满足如下两个条件：

>IC1’.所有的忠诚的下属相互之间在10分钟内发起进攻  
IC2’.如果发令将军是忠诚的，所有的忠诚的下属在发令者给定的命令时间点的10分钟之内发起进攻

(我们假设命令是在进攻的前一天下达并被处理的，而且与命令的接收时间无关，只需要关注命令中给定的进攻时间)

类似于拜占庭将军问题，这个问题只有在超过三分之二的将军是忠诚的时候才有解。我们通过表明这样的一个事实来证明它：如果存在这个问题的一个 *three-general solution* ，我们可以通过这个解构造出拜占庭将军问题的一个 *three-general solution* 。假设发令者希望发送一个进攻或者撤退命令。他会使用假设的那个算法，通过发送一个在1:00进行攻击的命令来作为进攻命令，通过发送在2:00进行攻击的命令作为撤退命令。每个下属使用下面的过程来获取命令：

>(1) 从发令者那收到攻击时间后，下属会执行下面中的一个：  
&nbsp;&nbsp;&nbsp;（a）如果时间是1:10或者更早，那么进攻  
&nbsp;&nbsp;&nbsp;（b）如果时间是1:50或者更晚，那么撤退  
&nbsp;&nbsp;&nbsp;（c）否则进行步骤(2)  
(2) 询问其他下属在步骤(1)得出的结果  
&nbsp;&nbsp;&nbsp;（a）如果其他下属得到了一个决定，那么使用与他相同的决定  
&nbsp;&nbsp;&nbsp;（b）否则撤退

根据IC2’如果发令者是忠诚的，那么一个忠诚的下属会在第一步里获取正确的命令，这样IC2就满足了。如果发令者是忠诚的，IC1可以由IC2导出。因此只需要证明当发令者是叛徒时的IC1成立即可。因为最多有一个叛徒，意味着两个下属都是忠诚的。根据IC1’，如果一个下属在步骤(1)里决定进攻，那么另一个就不能在步骤(1)决定撤退，因此要么他们在步骤(1)里都达到了相同的决定，要么至少其中一个将其决定推迟到了步骤(2) {注释：为什么会进入步骤2呢？因为当发令者是叛徒时，两个忠诚的下属达成的时间虽然相差在10分钟内但可能是随意的，比如可能在1:10-1:50之间,所以最后有可能两个都没有在第(1)阶段得出决定，而最后都选择撤退}。在这种情况下，很容易看出他们都达到了相同的决定，因此IC1满足。这样我们就构造出了对于存在一个叛徒的拜占庭将军问题的 *three-general solution* ，而这是不可能的。因此我们假设存在一个满足IC1’和IC2’的 *three-general solution* 是不成立的。

让1个将军模拟m个的方法也可以用在这里对于m个叛徒，小于3m+1个将军的情况下的证明。与之前原始的拜占庭将军问题的证明类似，因此我们将该证明留给读者来完成。

### 3、使用口头消息的解（A SOLUTION WITH ORAL MESSAGES）

前面我们指出，使用口头消息时对于一个含有m个叛徒的拜占庭将军问题，至少有3m+1个将军才可解。现在我们给出一个针对3m+1或更多将军的情况下的解。但是，首先我们需要明确“口头消息”的含义。每个将军都会执行某个算法来把消息传送给其他将军，同时我们假设忠诚的将军会正确地执行该算法。“口头消息”可以通过如下我们为将军消息系统所做的假设来具体定义：

>A1.每个发送的消息都会被正确的传输  
A2.消息的接收者知道是发送者是谁  
A3.消息的缺席可以检测出来  

假设A1和A2是防止叛徒介入其他两个将军的通信中，根据A1，他无法妨碍其他两位将军发送的消息，根据A2他不能伪造消息来搅乱其他两位将军的交流。假设A3是为了防止一个叛徒通过简单的不发送消息来阻止一次决定。这些假设在实际中的实现将会在第6节进行讨论。

本节以及下一节的算法，要求每个将军都能够直接向其他将军发送消息。在第5节我们会描述没有该条件限制下的算法。

一个叛变的发令者可能会决定不发送任何命令。由于下属们必须遵守相同的命令，因此这种情况下他们必须有一个默认的命令。我们使用RETREAT作为该默认命令。

算法首先需要一个函数*majority*，该函数有一个属性，当一系列元素(v<sub>1</sub>,v<sub>2</sub>…v<sub>n</sub>)中出现次数占半数以上的元素为v时，*majority*(v<sub>1</sub>,v<sub>2</sub>…v<sub>n</sub>) = v。更准确些，也就是说该函数并没有规定当不存在出现半数以上的元素同值时的值，所以该函数就有多种选择。对于*majority*(v<sub>1</sub>,v<sub>2</sub>…v<sub>n</sub>)有两种自然的选择：

&nbsp;&nbsp;&nbsp;1.如果存在出现半数以上的元素，它的值就是它，否则值为RETREAT。  
&nbsp;&nbsp;&nbsp;2.v<sub>i</sub>的中位数，假设他们是一组有序集合。

下面的算法仅需要借助于*majority*的前述属性。
>算法OM(0)  
&nbsp;&nbsp;&nbsp;(1) 发令者发送他的值给每个下属  
&nbsp;&nbsp;&nbsp;(2) 每个下属使用他从发令者那收到的值，如果没有收到则使用值RETREAT  
算法OM(m)  
&nbsp;&nbsp;&nbsp;(1) 发令者发送他的值给每个下属  
&nbsp;&nbsp;&nbsp;(2) 对于任意i，v<sub>i</sub>代表下属i从发令者处收到的值，如果没有收到则采用RETREAT。下属i扮演算法OM(m-1)中的发令者，并采用该算法将值v<sub>i</sub>发送给其余的n-2个下属  
&nbsp;&nbsp;&nbsp;(3) 对于任意i以及任意的 *j* != *i* ，让v<sub>j</sub>代表下属i在步骤2中(使用算法OM(m-1))从下属j处收到的值，如果他没有收到这样的值，就采用RETREAT。下属i采用函数 *majority(v<sub>1</sub>,v<sub>2</sub>…v<sub>n</sub>)* 的值

为了理解该算法是如何工作的，考虑 *m=1*，*n=4* 的情况，图3解释了当发令者发送值v，下属3为叛徒时，下属2接收到的消息。在OM(1)的第一步，发令者向所有其他三个下属发送值v。在第二步，下属1使用算法OM(0)将值v发送给下属2。也是在第二步里，下属3向下属2发送了某个其他值x。在第三步，下属2现在又 *v<sub>1</sub>=v<sub>2</sub>=v* 及 *v<sub>3</sub>=x* ，因此他会得到正确的值 *v=majority(v,v,x)* 。

![Fig 3. Algorithm OM(1); Lieutenant 3 a Traitor](./om1L31T.png)

下面我们看下，如果发令者是叛徒会如何。图4展示了当作为叛徒的发令者向三个下属发送三个的值x，y，z时，每个下属收到的值。每个下属都收到了v1=x,v2=y,v3=z，因此他们在第三步都获得了相同的值majority(x,y,z)，而无论这三个值x,y,z是否相等。

![Fig 3. Algorithm OM(1); The Commander a Traitor](./om1L3CT.png)

递归算法OM(m)会调用n-1个算法OM(m-1)的独立的执行实例，而每一个OM(m-1)又会调用n-2个OM(m-2)…。这意味着，对于m>1，一个下属会向其他下属发送很多独立的消息。必须要有某种方式用来区分这些不同的消息。读者可以验证，如果每个下属 i 将数字 i 加入到他在步骤2中发送的值 v<sub>i</sub> 的前缀中，所有的混淆之处都可以消除。伴随着递归的展开，算法OM(m-k)可能会被调用(n-1)…(n-k)次来发送由k个下属的序号组成的序列为前缀的值。

为了证明算法OM(m)对于任意m的正确性，我们首先证明如下的引理：

>Lemma 1.对于任意的m和k，如果存在超过2k+m个将军及最多k个叛徒，那么算法OM(m)满足IC2。

证明：证明是通过对m进行归纳法达到。IC2仅说明了当发令者是忠诚的时候需要满足的条件。根据A1，很容易得出如果发令者是忠诚的，算法OM(0)明显可以保证正确性，因此该定理在m=0时成立。  
在步骤(1)，诚实的发令者会给所有的n-1个下属发送它的值。在步骤(2)，每个忠诚的下属会在将军数为n-1的情况下应用OM(m-1)。根据假设n>2k+m，可以推出n-1>2k+(m-1)，因此我们可以利用归纳假设得出每个忠诚的下属从其他的忠诚的下属 j 那得到 *v<sub>j</sub>=v*。因为最多有k个叛徒，同时 *n-1>2k+(m-1)>2k* ，因此n-1个下属中，至少一半以上是忠诚的，这样每个忠诚的下属收到的(v<sub>1</sub>,v<sub>2</sub>…v<sub>n-1</sub>)中，就有一半以上是v，因此在步骤三，他会得到 *majority(v<sub>1</sub>,v<sub>2</sub>…v<sub>n-1</sub>)=v* ，这样就满足了条件IC2。

下面的这个定理说明算法OM(m)解决了拜占庭将军问题。

>THEOREM1.对于任意的m，如果有多于3m个将军及最多m个叛徒，则算法OM(m)可以满足条件IC1和IC2。

证明：证明是通过在m上进行归纳得出。如果没有叛徒，很明显OM(0)满足条件IC1和IC2。现在我们假设对于OM(m-1)成立，然后证明OM(m)也成立，m>0。  
首先考虑发令者是忠诚的情况，根据Lemma1，那里的k即现在的m，可以得出OM(m)满足条件IC2，如果发令者是忠诚的，IC1可以直接由IC2导出。因此，我们现在只需要当发令者是叛徒的情况下，IC1是否成立。  
由于最多有m个叛徒，而发令者现在是其中之一，因此最多有m-1个下属是叛徒。因为有多于3m个将军，这样就有多于3m-1个下属，同时3m-1>3(m-1)。因此，我们可以应用归纳假设得出OM（m-1）满足条件IC1和IC2的结论。因此对于任意的将军 j，任两个忠诚的将军在步骤三会得到相同的v<sub>j</sub>值(如果两个将军其中一个 j，则该结果可以通过IC2得出，否则可以通过IC1得出)。因此任意两个忠诚的将军会得到相同的序列 *(v<sub>1</sub>,v<sub>2</sub>…v<sub>n-1</sub>)* 值。因此在步骤三得到的 *majority(v<sub>1</sub>,v<sub>2</sub>…v<sub>n-1</sub>)* 的值相同，这就证明了IC1。

### 4、使用签名消息情况下的解（A SOLUTION WITH SIGNED MESSAGES）

正如我们从图1和图2看到的情形，正是叛徒可以撒谎的能力使得拜占庭将军问题变得难解。如果可以限制他们的这种能力，那么问题就会变得容易解决了。一种方式是允许将军发送不可伪造的签名的消息。准确的讲，我们可以给A1-A3增加如下新的假设：
>A4  
&nbsp;&nbsp;&nbsp;(a)忠诚的将军的签名不可以被伪造，他的签名信息的内容的任何改动都可以被检测。  
&nbsp;&nbsp;&nbsp;(b)任何人可以验证签名的真实性。

注意我们没有对叛变的将军的签名做任何限制，尤其是我们允许他的签名可以被另一个叛徒伪造，因此可能出现在叛徒间的勾结。

引入签名消息之后，我们之前的处理一个叛徒至少需要四个将军的结论就不再成立了。实际上确实存在一个三将军情况下的解。下面我们给出一个算法，该算法可以处理任意将军数，m叛徒数的情况。(当将军数小于m+2时，该问题是显而易见的。)

在我们的算法中，发令者给他的每个下属发送一个签名命令，然后每个下属又在该命令上添加上自己的签名，然后再发送给其他人，收到消息的人，继续添加自己的签名，如何反复进行….。这就要求一个下属必须可以有效的接受签名消息，弄出很多份拷贝，签名然后发送出很多份拷贝。这些拷贝如何产生无关紧要，消息可能是被完全影印出来，可能是一系列的相同签名消息的栈，然后被分发出去。

算法假设有一个函数 *choice* ，用来从一组命令中选出一个来。对该函数唯一的需求是：
>1.如果集合V只有一个元素 v，那么 *choice(V)=v*  
2.*Choice(空集)=RETREAT*  
>
>NOTE 一种可行的定义是，让 *choice(V)* 代表集合V的中位数-假设集合元素是可排序的。

在下面的算法中，我们让 *x:i* 代表值 x 经过将军 i 签名后的形式，因此 *v:j:i* 代表值 v 经过 j 签名的值 *v:j* 又经过了 i 的签名。假设0代表发令将军。在算法中，每个下属 i 维护一个集合 V<sub>i</sub> ，包含了目前为止他所收到的有效的签名命令(如果发令者是忠诚的，那个该集合中不会超过一个元素)。不要把 V<sub>i</sub> ——收到的命令集合——与收到的消息集合搞混了，这两个是不同的概念。同一个命令可能会被包含在多个不同的消息中。

>Algorithm SM (m).   
初始化，V<sub>i</sub> = Ø  
&nbsp;&nbsp;&nbsp;(1)发令者签名，然后将他的消息发送给每个下属  
&nbsp;&nbsp;&nbsp;(2)对于任意的i：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A)如果下属i从发令者处收到了一个形如 *v:0* 的消息，同时目前为止他还未收到任何其他命令，那么：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i)让 *V<sub>i</sub> = {v}*  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ii)向其他下属发送消息 *v:0:i*  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B)如果下属 i 收到过形如 *v:0:j<sub>1</sub>:…:j<sub>k</sub>* 的消息，同时v还未出现在集合 V<sub>i</sub> 中，那么：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i)将 v 添加到 V<sub>i</sub>  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ii)如果k<m,那么他就向除j<sub>1</sub>:…:j<sub>k</sub>之外的其他下属发送消息 v:0:j<sub>1</sub>:…:j<sub>k</sub>:i  
&nbsp;&nbsp;&nbsp;(3)对于任意i：当下属i不再收到任何消息时，他选择choice(Vi)的值作为命令。<br>  
NOTE 在步骤(2)，下属 i 会忽略已经包含在集合 V<sub>i</sub> 中的命令的所有消息。

目前，还有一点未说明的就是在每个下属在步骤(3)如何判断他不会再收到任何消息。通过对k进行归纳法，容易得到对于任意的下属序列j1,…,jk(k<=m)，一个下属最多会收到一条形式为v:0:j1:…:jk的消息。如果我们要求下属i要么发送注这样的一条消息，要么发送一条消息报告他不会发送这样的一条消息，这样就很容易确定是否所有的消息已经被接收到。(根据假设A3，下属可以确定一个叛变的下属将军是否会选择不发送这两类消息)。此外超时机制也可以用来确定是否不再有消息到达。在第6节还会讨论关于超时的使用方法。














